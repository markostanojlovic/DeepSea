# -*- coding: utf-8 -*-
"""
This module is responsible for the parsing of DeepSea stage files
"""
from __future__ import absolute_import
from __future__ import print_function

import logging
import os

import salt.client

from .common import redirect_stdout


# pylint: disable=C0103
logger = logging.getLogger(__name__)


__opts__ = salt.config.minion_config('/etc/salt/minion')
__opts__['file_client'] = 'local'
__caller__ = salt.client.Caller(mopts=__opts__)


class OrchestrationNotFound(Exception):
    """
    No orchestration file found exception
    """
    pass


class SLSRenderer(object):
    """
    Helper class to render sls files
    """

    @staticmethod
    def render(file_name):
        """
        This function makes use of slsutil salt module to render sls files
        Args:
            file_name (str): the sls file path
        """
        with redirect_stdout(os.devnull):
            result = __caller__.cmd('slsutil.renderer', file_name)
        return result


class SLSParser(object):
    """
    SLS files parser
    """

    @staticmethod
    def _state_name_is_dir(state_name):
        """
        Checks wheather a state_name corresponds to a directory in the filesystem.
        """
        path = "/srv/salt/{}".format(state_name.replace(".", "/"))
        return os.path.isdir(path)

    @staticmethod
    def _state_file_path(state_name):
        """
        Returns the filesystem path of a state file
        Args:
            state_name (str): the salt state name
        """
        if SLSParser._state_name_is_dir(state_name):
            path = "/srv/salt/{}/init.sls".format(state_name.replace(".", "/"))
        else:
            path = "/srv/salt/{}.sls".format(state_name.replace(".", "/"))

        if not os.path.exists(path):
            raise OrchestrationNotFound("could not determine path for {}"
                                        .format(state_name))

        return path

    @staticmethod
    def _gen_state_name_from_include(parent_state, include):
        """
        Generates the salt state name from a state include path.
        Example:
        ceph.stage.4 state contents:

        .. code-block:: yaml
            include:
              - ..iscsi

        The state name generated by this include will be:
        ceph.stage.iscsi
        """
        # counting dots
        dot_count = 0
        for c in include:
            if c == '.':
                dot_count += 1
            else:
                break
        include = include[dot_count:]
        if not SLSParser._state_name_is_dir(parent_state):
            # we need to remove the "file_name" part of the parent state name
            dot_count += 1
        if dot_count > 1:
            # The state it's not ceph.stage.4.iscsi but ceph.stage.iscsi if
            # the include has two dots (..) in it.
            parent_state = ".".join(parent_state.split('.')[:-(dot_count - 1)])

        return "{}.{}".format(parent_state, include)

    @staticmethod
    def parse_state_steps(state_name, only_events=True):
        """
        Parses the all steps (actions) triggered by the execution of a state file
        Args:
            state_name (str): the salt state name, e.g., ceph.stage.1

        Returns:
            list(StepType): a list of steps
        """
        result = []
        path = SLSParser._state_file_path(state_name)
        state_dict = SLSRenderer.render(path)
        logger.info("Parsing state file: %s", path)
        for key, steps in state_dict.items():
            if key == 'include':
                for inc in state_dict['include']:
                    logger.debug("Handling include of: parent={} include={}"
                                 .format(state_name, inc))
                    include_state_name = SLSParser._gen_state_name_from_include(state_name, inc)
                    result.extend(SLSParser.parse_state_steps(include_state_name, only_events))
            else:
                if isinstance(steps, dict):
                    for fun, args in steps.items():
                        logger.debug("Parsing step: desc={} fun={} step={}".format(key, fun, args))
                        if fun == 'salt.state':
                            state = SaltState(key, args)
                            result.append(state)
                            result.extend(SLSParser.parse_state_steps(state.state, only_events))
                        elif fun == 'salt.runner':
                            result.append(SaltRunner(key, args))
                        elif fun == 'module.run':
                            result.append(SaltModule(key, args))
                        else:
                            builtin = SaltBuiltIn(key, fun, args)
                            if not only_events or ('fire_event' in builtin.args and
                                                   builtin.args['fire_event']):
                                result.append(SaltBuiltIn(key, fun, args))

        return result


class SaltType(object):
    """
    Base class to represent a single stage step
    """
    def __init__(self, desc, args):
        self.desc = desc
        self.args = args

    def __repr__(self):
        return self.desc

    def _get_arg(self, key):
        """
        Returns the arg value for the key
        """
        return [arg for arg in self.args if key in arg][0][key]


class SaltState(SaltType):
    """
    Class to represent a Salt state apply step
    """
    def __init__(self, desc, args):
        super(SaltState, self).__init__(desc, args)
        self.state = self._get_arg('sls')
        self.target = self._get_arg('tgt')

    def __repr__(self):
        return "SaltState(desc: {}, state: {}, target: {})".format(self.desc, self.state,
                                                                   self.target)


class SaltRunner(SaltType):
    """
    Class to represent a Salt runner step
    """
    def __init__(self, desc, args):
        super(SaltRunner, self).__init__(desc, args)
        self.fun = self._get_arg('name')

    def __repr__(self):
        return "SaltRunner(desc: {}, fun: {})".format(self.desc, self.fun)


class SaltModule(SaltType):
    """
    Class to represent a Salt module step
    """
    def __init__(self, desc, args):
        super(SaltModule, self).__init__(desc, args)
        self.fun = self._get_arg('name')

    def __repr__(self):
        return "SaltModule(desc: {}, fun: {})".format(self.desc, self.fun)


class SaltBuiltIn(SaltType):
    """
    Class to represent a Salt built-in command step

    Built-in commands like cmd.run and file.managed need
    to be condensed.
    """
    def __init__(self, desc, fun, args):
        super(SaltBuiltIn, self).__init__(desc, args)
        self.fun = fun
        self.args = dict()
        for arg in args:
            if isinstance(arg, dict):
                for key, val in arg.items():
                    self.args[key] = val
            else:
                self.args['nokey'] = arg

    def __repr__(self):
        return "SaltBuiltIn(desc: {}, fun: {}, args: {})".format(self.desc, self.fun, self.args)
